#include "./events/dispatch/dispatchers.h"

// This file is autogenerated, based on dispatchers.toml
// Do not edit!


// Lesson learned: do not #define _Container!
#include <iostream>

#include <dispatch_base.h>
#include <water.h>
#include <entity.h>

#include <../collisionhandler.h>
#include <../ia_enterhandler.h>
#include <../ia_leavehandler.h>

// Empty


// CollisionDispatch

int CollisionDispatch::getRule(Entity* __Entity0, Entity* __Entity1) {
    // Rule 0
    Water* __r0_Water0 = dynamic_cast<Water*>(__Entity0);
    Entity* __r0_Entity1 = dynamic_cast<Entity*>(__Entity1);
    if (__r0_Water0 != nullptr && __r0_Entity1 != nullptr) {
        return 0;
    }


    return -1;
}
    
int CollisionDispatch::doRule(int rulenum, Entity* __Entity0, Entity* __Entity1) {
    switch(rulenum) {

        case 0:
            return onCollision(dynamic_cast<Water*>(__Entity0), dynamic_cast<Entity*>(__Entity1));

        default:
            return onCollision(dynamic_cast<Entity*>(__Entity0), dynamic_cast<Entity*>(__Entity1));
    }
}




// IA_EnterDispatch

int IA_EnterDispatch::getRule(Entity* __Entity0, Entity* __Entity1) {

    return -1;
}
    
void IA_EnterDispatch::doRule(int rulenum, Entity* __Entity0, Entity* __Entity1) {
    switch(rulenum) {

        default:
            return onEnter(dynamic_cast<Entity*>(__Entity0), dynamic_cast<Entity*>(__Entity1));
    }
}




// IA_LeaveDispatch

int IA_LeaveDispatch::getRule(Entity* __Entity0, Entity* __Entity1) {

    return -1;
}
    
void IA_LeaveDispatch::doRule(int rulenum, Entity* __Entity0, Entity* __Entity1) {
    switch(rulenum) {

        default:
            return onLeave(dynamic_cast<Entity*>(__Entity0), dynamic_cast<Entity*>(__Entity1));
    }
}



